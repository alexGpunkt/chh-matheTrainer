<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8">

<!-- üì± Mobile Optimierung -->
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

<title>Mathe Pr√ºfung ‚Äì Niveau 11.3 ‚≠ê</title>

<!-- ZENTRALER AUFGABENPOOL (11.3) -->
<script src="pool_113.js"></script>

<style>
html, body {
  overflow: hidden;
  touch-action: manipulation;
}
* {
  box-sizing: border-box;
  touch-action: manipulation;
}
body {
  font-family: system-ui, Arial, sans-serif;
  background: #e9e9e9;
  margin: 0;
  padding: 12px;
}
h1 {
  text-align: center;
  font-size: clamp(1.3rem, 4vw, 2rem);
  margin-bottom: 10px;
}
#topbar {
  display: flex;
  flex-wrap: wrap;
  justify-content: center;
  gap: 8px;
  margin-bottom: 10px;
}
select, button, label {
  font-size: 1rem;
  padding: 12px 14px;
  border-radius: 8px;
  border: 1px solid #999;
}
button {
  background: #1976d2;
  color: white;
  border: none;
  cursor: pointer;
}
button:active { background: #0d47a1; }
button:disabled {
  background: #cccccc;
  cursor: not-allowed;
}
#timer {
  width: 100%;
  text-align: center;
  font-size: 1.2rem;
  font-weight: bold;
  color: darkred;
}
#card {
  background: white;
  padding: 16px;
  border-radius: 12px;
  max-width: 900px;
  margin: auto;
}
#task {
  font-size: clamp(1.1rem, 4vw, 1.4rem);
  margin-bottom: 14px;
}
#answerArea {
  display: flex;
  flex-direction: column;
  gap: 10px;
}
input {
  font-size: 1.3rem;
  padding: 12px;
  border-radius: 8px;
  border: 1px solid #aaa;
  width: 100%;
}
.hidden { display: none; }
#navButtons {
  display: flex;
  gap: 10px;
  margin-top: 12px;
}
#navButtons button { flex: 1; }
#result {
  font-size: 1.3rem;
  font-weight: bold;
  margin-top: 15px;
  text-align: center;
}

/* üì± Extra Optimierung f√ºr sehr kleine Displays */
@media (max-width: 480px) {
  h1 { font-size: 1.3rem; }
  #task { font-size: 1.15rem; }
}
</style>
</head>

<body>

<h1>üìù Mathematik ‚Äì Pr√ºfungsmodus 11.3 (Note 1‚Äì2)</h1>

<div id="topbar">
  <button id="startBtn">Pr√ºfung starten</button>
  <div id="timer" class="hidden"></div>
</div>

<div id="card">
  <div id="task">Noch keine Pr√ºfung gestartet.</div>

  <div id="answerArea" class="hidden">
    <input type="text" id="answer"
           inputmode="decimal"
           placeholder="Antwort eingeben">
    <div id="navButtons">
      <button id="nextBtn">Weiter</button>
      <button id="finishBtn">Abgeben</button>
    </div>
  </div>

  <div id="result"></div>
</div>

<script>
/* =======================
   KONFIG (wie 10.1 Layout, aber 12.2 Prozess)
======================= */
const EXAM_TIME = 90 * 60;    // 90 Minuten
const TASKS_TOTAL = 10;
const POINTS_PER_TASK = 3;
const PASS_POINTS = 24;       // Niveau 11.3: eher hoch (z.B. 8/10 richtig)
const TEACHER_PIN = "1234";   // optionaler Abschluss-Schutz

/* =======================
   DOM
======================= */
const startBtnEl  = document.getElementById("startBtn");
const timerEl     = document.getElementById("timer");
const taskEl      = document.getElementById("task");
const answerAreaEl= document.getElementById("answerArea");
const answerEl    = document.getElementById("answer");
const nextBtnEl   = document.getElementById("nextBtn");
const finishBtnEl = document.getElementById("finishBtn");
const resultEl    = document.getElementById("result");

/* =======================
   STATE (analog 12.2 Round-State)
======================= */
let timeLeft = 0;
let timerInt = null;

let roundActive = false;
let taskNumber = 0;
let points = 0;

let currentAnswer = null;
let solvedCurrent = false;

let lastCat = null;
let lastGenIndex = null;

/* =======================
   UTIL (wie 12.2)
======================= */
function rand(min, max) {
  return Math.floor(Math.random() * (max - min + 1)) + min;
}

function normalize(val) {
  return parseFloat(String(val).trim().replace(",", "."));
}

function fmt(n) {
  if (typeof n === "number") {
    if (Number.isInteger(n)) return String(n);
    return (Math.round(n * 100) / 100).toString().replace(".", ",");
  }
  return String(n);
}

/* =======================
   TASKPOOL Zugriff (pool_113.js)
======================= */
function getTaskpoolOrFail() {
  const tp = window.TASKPOOL;
  if (!tp || typeof tp !== "object") {
    alert("Fehler: window.TASKPOOL fehlt. Wurde pool_113.js korrekt geladen?");
    return null;
  }
  const cats = Object.keys(tp).filter(c => Array.isArray(tp[c]) && tp[c].length > 0);
  if (cats.length === 0) {
    alert("Fehler: TASKPOOL hat keine gef√ºllten Kategorien.");
    return null;
  }
  return { tp, cats };
}

/* =======================
   KATEGORIE-GEWICHTUNG (optional)
   - Wenn Kategorien im pool_113.js anders hei√üen, wird automatisch fallback genutzt.
======================= */
function buildWeightedCategories(availableCats) {
  // bevorzugte Kategorien (falls vorhanden)
  const preferred = [
    "basis","rechnen","prozent","zuordnung","wahrscheinlichkeit",
    "statistik","geometrie","flaeche2d","koerper","pythagoras",
    "koordinaten","sach","terme","gleichungen"
  ];

  // Nimm nur die, die es wirklich gibt
  const existingPreferred = preferred.filter(c => availableCats.includes(c));

  // Wenn nichts passt: einfach alle Kategorien gleichwahrscheinlich
  if (existingPreferred.length === 0) return availableCats.slice();

  // Gewichtung wie ‚Äûpr√ºfungsnah‚Äú: einige doppelt
  const weighted = [];
  const add = (cat, k) => { for (let i=0;i<k;i++) weighted.push(cat); };

  existingPreferred.forEach(cat => {
    // Kernbereiche etwas h√§ufiger
    if (["rechnen","prozent","geometrie","koerper","pythagoras","gleichungen","terme"].includes(cat)) add(cat, 3);
    else add(cat, 2);
  });

  return weighted.length ? weighted : availableCats.slice();
}

let weightedCategoriesCache = null;

function pickCategoryWeighted(availableCats) {
  if (!weightedCategoriesCache) {
    weightedCategoriesCache = buildWeightedCategories(availableCats);
  }
  return weightedCategoriesCache[rand(0, weightedCategoriesCache.length - 1)];
}

/* =======================
   drawTask (wie 12.2)
======================= */
function drawTask(cat, genIndex, tp) {
  const gen = tp[cat][genIndex];
  const t = gen();

  // Erwartete Struktur: { task, answer, solution? }
  if (!t || typeof t !== "object" || !("task" in t) || !("answer" in t)) {
    console.error("Generator lieferte ung√ºltiges Objekt:", t);
    alert("Fehler: Eine Aufgabe aus pool_113.js ist ung√ºltig (kein task/answer).");
    return false;
  }

  lastCat = cat;
  lastGenIndex = genIndex;

  currentAnswer = t.answer;
  solvedCurrent = false;

  const starMark = (t.star === true) ? " ‚≠ê" : "";

  taskEl.innerHTML = `<b>Aufgabe ${taskNumber}/${TASKS_TOTAL}${starMark}</b><br>${t.task}`;
  answerEl.value = "";
  answerEl.focus();

  return true;
}

/* =======================
   ROUND START (wie 12.2 startRound, nur mit Timer + UI wie 10.1)
======================= */
function startRound() {
  const pack = getTaskpoolOrFail();
  if (!pack) return;

  points = 0;
  taskNumber = 0;
  roundActive = true;
  solvedCurrent = false;
  lastCat = null;
  lastGenIndex = null;
  weightedCategoriesCache = null;

  timeLeft = EXAM_TIME;
  resultEl.innerHTML = "";

  // UI
  startBtnEl.disabled = true;
  answerAreaEl.classList.remove("hidden");
  timerEl.classList.remove("hidden");

  clearInterval(timerInt);
  timerInt = setInterval(updateTimer, 1000);

  // Erste Aufgabe sofort wie 12.2: startRound() -> nextTaskRandom()
  nextTaskRandom();
}

/* =======================
   NEXT RANDOM (wie 12.2 nextTaskRandom)
======================= */
function nextTaskRandom() {
  if (!roundActive) {
    alert("Bitte zuerst auf ‚ÄûPr√ºfung starten‚Äú klicken!");
    return;
  }

  const pack = getTaskpoolOrFail();
  if (!pack) return;

  if (taskNumber >= TASKS_TOTAL) {
    finishRound(); // analog 12.2 finishRound (hier: Abschluss)
    return;
  }

  taskNumber++;

  // Pick category + generator
  const cat = pickCategoryWeighted(pack.cats);

  // Fallback: falls cat existiert aber aus irgendeinem Grund leer wurde
  const list = pack.tp[cat];
  if (!Array.isArray(list) || list.length === 0) {
    // fallback: irgendeine gef√ºllte Kategorie
    const fallbackCat = pack.cats[rand(0, pack.cats.length - 1)];
    const genIndex = rand(0, pack.tp[fallbackCat].length - 1);
    drawTask(fallbackCat, genIndex, pack.tp);
    return;
  }

  const genIndex = rand(0, list.length - 1);
  drawTask(cat, genIndex, pack.tp);
}

/* =======================
   ANSWER CHECK + SCORE (wie 12.2 checkAnswer -> Punkte)
======================= */
function checkAndScoreCurrent() {
  if (!roundActive || solvedCurrent) return;

  const inputRaw = answerEl.value.trim();
  if (inputRaw === "") return;

  // String-Antwort (z.B. Uhrzeiten "12:35")
  if (typeof currentAnswer === "string") {
    const ok = (inputRaw === currentAnswer);
    if (ok) points += POINTS_PER_TASK;
    solvedCurrent = true;
    return;
  }

  // Zahl-Antwort
  const userVal = normalize(inputRaw);
  if (isNaN(userVal)) {
    // nicht werten, aber auch nicht blocken
    return;
  }

  if (Math.abs(userVal - currentAnswer) < 0.05) {
    points += POINTS_PER_TASK;
  }
  solvedCurrent = true;
}

function saveAndNext() {
  if (!roundActive) return;

  checkAndScoreCurrent();

  // n√§chste Aufgabe wie 12.2 (dort pr√ºft nextTaskRandom selbst das Limit)
  nextTaskRandom();
}

/* =======================
   FINISH
======================= */
function finishRound() {
  if (!roundActive) return;

  // Letzte Eingabe ggf. noch werten, wenn wir mitten drin abbrechen
  checkAndScoreCurrent();

  // optional PIN
  const pin = prompt("Lehrer-PIN eingeben (Demo: 1234):");
  if (pin !== TEACHER_PIN) {
    alert("Falsche PIN - Pr√ºfung kann nicht abgeschlossen werden.");
    return;
  }

  roundActive = false;

  clearInterval(timerInt);
  timerInt = null;

  answerAreaEl.classList.add("hidden");
  timerEl.classList.add("hidden");
  startBtnEl.disabled = false;

  const res = points >= PASS_POINTS ? "‚úÖ BESTANDEN" : "‚ùå NICHT BESTANDEN";
  resultEl.innerHTML = `Punkte: <b>${points} / ${TASKS_TOTAL * POINTS_PER_TASK}</b><br>${res}`;

  taskEl.innerHTML = "Pr√ºfung beendet. Neustart m√∂glich.";
}

/* =======================
   TIMER (wie 10.1)
======================= */
function updateTimer() {
  if (!roundActive) return;

  timeLeft--;
  const m = Math.floor(timeLeft / 60);
  const s = (timeLeft % 60).toString().padStart(2, "0");
  timerEl.innerText = `‚è± ${m}:${s}`;

  if (timeLeft <= 0) {
    finishRound();
  }
}

/* =======================
   VERLASSEN-WARNUNG (wie 10.1)
======================= */
window.addEventListener("beforeunload", function (e) {
  if (roundActive) {
    e.preventDefault();
    e.returnValue = "Der Test l√§uft noch. Bitte zuerst abgeben.";
  }
});

/* =======================
   EVENTS
======================= */
startBtnEl.addEventListener("click", startRound);
nextBtnEl.addEventListener("click", saveAndNext);
finishBtnEl.addEventListener("click", finishRound);

// Enter-Taste -> Weiter
answerEl.addEventListener("keypress", function(e) {
  if (e.key === "Enter" && roundActive) {
    e.preventDefault();
    saveAndNext();
  }
});
</script>

</body>
</html>
